
        /* Automatically generated by parse_opcodes */
impl<'a> RawRISCVAssembler<'a> {

    pub fn add(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = add(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn add_uw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = add_uw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn addi(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = addi(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn addiw(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = addiw(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn addw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = addw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn aes64ds(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = aes64ds(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn aes64dsm(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = aes64dsm(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn aes64es(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = aes64es(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn aes64esm(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = aes64esm(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn aes64im(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = aes64im(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn aes64ks1i(&mut self, rd: Reg, rs1: Reg, rnum: Reg) -> Result<(), AsmError> {
        let inst = aes64ks1i(rd, rs1, rnum);

        self.emit(inst);

        Ok(())
    }
        
    pub fn aes64ks2(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = aes64ks2(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoadd_b(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoadd_b(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoadd_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoadd_d(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoadd_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoadd_h(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoadd_w(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoadd_w(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoand_b(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoand_b(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoand_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoand_d(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoand_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoand_h(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoand_w(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoand_w(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amocas_b(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amocas_b(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amocas_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amocas_d(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amocas_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amocas_h(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amocas_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amocas_q(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amocas_w(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amocas_w(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomax_b(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomax_b(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomax_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomax_d(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomax_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomax_h(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomax_w(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomax_w(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomaxu_b(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomaxu_b(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomaxu_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomaxu_d(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomaxu_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomaxu_h(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomaxu_w(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomaxu_w(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomin_b(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomin_b(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomin_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomin_d(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomin_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomin_h(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amomin_w(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amomin_w(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amominu_b(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amominu_b(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amominu_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amominu_d(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amominu_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amominu_h(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amominu_w(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amominu_w(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoor_b(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoor_b(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoor_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoor_d(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoor_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoor_h(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoor_w(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoor_w(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoswap_b(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoswap_b(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoswap_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoswap_d(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoswap_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoswap_h(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoswap_w(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoswap_w(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoxor_b(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoxor_b(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoxor_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoxor_d(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoxor_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoxor_h(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn amoxor_w(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = amoxor_w(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn and(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = and(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn andi(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = andi(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn andn(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = andn(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn auipc(&mut self, rd: Reg, imm20: i32) -> Result<(), AsmError> {
        let inst = auipc(rd, imm20);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bclr(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = bclr(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bclri(&mut self, rd: Reg, rs1: Reg, shamtd: u32) -> Result<(), AsmError> {
        let inst = bclri(rd, rs1, shamtd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn beq(&mut self, bimm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = beq(bimm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn beqz(&mut self, bimm12lohi: i32, rs1: Reg) -> Result<(), AsmError> {
        let inst = beqz(bimm12lohi, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bext(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = bext(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bexti(&mut self, rd: Reg, rs1: Reg, shamtd: u32) -> Result<(), AsmError> {
        let inst = bexti(rd, rs1, shamtd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bge(&mut self, bimm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = bge(bimm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bgeu(&mut self, bimm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = bgeu(bimm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bgez(&mut self, bimm12lohi: i32, rs1: Reg) -> Result<(), AsmError> {
        let inst = bgez(bimm12lohi, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bgt(&mut self, bimm12lohi: i32, rs2: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = bgt(bimm12lohi, rs2, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bgtu(&mut self, bimm12lohi: i32, rs2: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = bgtu(bimm12lohi, rs2, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bgtz(&mut self, bimm12lohi: i32, rs2: Reg) -> Result<(), AsmError> {
        let inst = bgtz(bimm12lohi, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn binv(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = binv(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn binvi(&mut self, rd: Reg, rs1: Reg, shamtd: u32) -> Result<(), AsmError> {
        let inst = binvi(rd, rs1, shamtd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn ble(&mut self, bimm12lohi: i32, rs2: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = ble(bimm12lohi, rs2, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bleu(&mut self, bimm12lohi: i32, rs2: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = bleu(bimm12lohi, rs2, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn blez(&mut self, bimm12lohi: i32, rs2: Reg) -> Result<(), AsmError> {
        let inst = blez(bimm12lohi, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn blt(&mut self, bimm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = blt(bimm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bltu(&mut self, bimm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = bltu(bimm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bltz(&mut self, bimm12lohi: i32, rs1: Reg) -> Result<(), AsmError> {
        let inst = bltz(bimm12lohi, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bne(&mut self, bimm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = bne(bimm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bnez(&mut self, bimm12lohi: i32, rs1: Reg) -> Result<(), AsmError> {
        let inst = bnez(bimm12lohi, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn brev8(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = brev8(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bset(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = bset(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn bseti(&mut self, rd: Reg, rs1: Reg, shamtd: u32) -> Result<(), AsmError> {
        let inst = bseti(rd, rs1, shamtd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn c_add(&mut self, rd_rs1_n0: Reg, c_rs2_n0: u32) -> Result<(), AsmError> {
        let inst = c_add(rd_rs1_n0, c_rs2_n0);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_addi(&mut self, rd_rs1_n0: Reg, c_nzimm6lohi: i32) -> Result<(), AsmError> {
        let inst = c_addi(rd_rs1_n0, c_nzimm6lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_addi16sp(&mut self, c_nzimm10lohi: i32) -> Result<(), AsmError> {
        let inst = c_addi16sp(c_nzimm10lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_addi4spn(&mut self, rd_p: Reg, c_nzuimm10: u32) -> Result<(), AsmError> {
        let inst = c_addi4spn(rd_p, c_nzuimm10);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_addiw(&mut self, rd_rs1_n0: Reg, c_imm6lohi: i32) -> Result<(), AsmError> {
        let inst = c_addiw(rd_rs1_n0, c_imm6lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_addw(&mut self, rd_rs1_p: Reg, rs2_p: Reg) -> Result<(), AsmError> {
        let inst = c_addw(rd_rs1_p, rs2_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_and(&mut self, rd_rs1_p: Reg, rs2_p: Reg) -> Result<(), AsmError> {
        let inst = c_and(rd_rs1_p, rs2_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_andi(&mut self, rd_rs1_p: Reg, c_imm6lohi: i32) -> Result<(), AsmError> {
        let inst = c_andi(rd_rs1_p, c_imm6lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_beqz(&mut self, rs1_p: Reg, c_bimm9lohi: i32) -> Result<(), AsmError> {
        let inst = c_beqz(rs1_p, c_bimm9lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_bnez(&mut self, rs1_p: Reg, c_bimm9lohi: i32) -> Result<(), AsmError> {
        let inst = c_bnez(rs1_p, c_bimm9lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_ebreak(&mut self, ) -> Result<(), AsmError> {
        let inst = c_ebreak();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_fld(&mut self, rd_p: Reg, rs1_p: Reg, c_uimm8lohi: u32) -> Result<(), AsmError> {
        let inst = c_fld(rd_p, rs1_p, c_uimm8lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_fldsp(&mut self, rd: Reg, c_uimm9splohi: u32) -> Result<(), AsmError> {
        let inst = c_fldsp(rd, c_uimm9splohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_fsd(&mut self, rs1_p: Reg, rs2_p: Reg, c_uimm8lohi: u32) -> Result<(), AsmError> {
        let inst = c_fsd(rs1_p, rs2_p, c_uimm8lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_fsdsp(&mut self, c_rs2: u32, c_uimm9sp_s: u32) -> Result<(), AsmError> {
        let inst = c_fsdsp(c_rs2, c_uimm9sp_s);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_j(&mut self, c_imm12: i32) -> Result<(), AsmError> {
        let inst = c_j(c_imm12);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_jalr(&mut self, c_rs1_n0: u32) -> Result<(), AsmError> {
        let inst = c_jalr(c_rs1_n0);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_jr(&mut self, rs1_n0: Reg) -> Result<(), AsmError> {
        let inst = c_jr(rs1_n0);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_lbu(&mut self, rd_p: Reg, rs1_p: Reg, c_uimm2: u32) -> Result<(), AsmError> {
        let inst = c_lbu(rd_p, rs1_p, c_uimm2);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_ld(&mut self, rd_p: Reg, rs1_p: Reg, c_uimm8lohi: u32) -> Result<(), AsmError> {
        let inst = c_ld(rd_p, rs1_p, c_uimm8lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_ldsp(&mut self, rd_n0: Reg, c_uimm9splohi: u32) -> Result<(), AsmError> {
        let inst = c_ldsp(rd_n0, c_uimm9splohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_lh(&mut self, rd_p: Reg, rs1_p: Reg, c_uimm1: u32) -> Result<(), AsmError> {
        let inst = c_lh(rd_p, rs1_p, c_uimm1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_lhu(&mut self, rd_p: Reg, rs1_p: Reg, c_uimm1: u32) -> Result<(), AsmError> {
        let inst = c_lhu(rd_p, rs1_p, c_uimm1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_li(&mut self, rd_n0: Reg, c_imm6lohi: i32) -> Result<(), AsmError> {
        let inst = c_li(rd_n0, c_imm6lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_lui(&mut self, rd_n2: Reg, c_nzimm18lohi: i32) -> Result<(), AsmError> {
        let inst = c_lui(rd_n2, c_nzimm18lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_lw(&mut self, rd_p: Reg, rs1_p: Reg, c_uimm7lohi: u32) -> Result<(), AsmError> {
        let inst = c_lw(rd_p, rs1_p, c_uimm7lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_lwsp(&mut self, rd_n0: Reg, c_uimm8splohi: u32) -> Result<(), AsmError> {
        let inst = c_lwsp(rd_n0, c_uimm8splohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_mop_1(&mut self, ) -> Result<(), AsmError> {
        let inst = c_mop_1();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_mop_11(&mut self, ) -> Result<(), AsmError> {
        let inst = c_mop_11();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_mop_13(&mut self, ) -> Result<(), AsmError> {
        let inst = c_mop_13();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_mop_15(&mut self, ) -> Result<(), AsmError> {
        let inst = c_mop_15();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_mop_3(&mut self, ) -> Result<(), AsmError> {
        let inst = c_mop_3();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_mop_5(&mut self, ) -> Result<(), AsmError> {
        let inst = c_mop_5();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_mop_7(&mut self, ) -> Result<(), AsmError> {
        let inst = c_mop_7();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_mop_9(&mut self, ) -> Result<(), AsmError> {
        let inst = c_mop_9();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_mop_n(&mut self, c_mop_t: u32) -> Result<(), AsmError> {
        let inst = c_mop_n(c_mop_t);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_mul(&mut self, rd_rs1_p: Reg, rs2_p: Reg) -> Result<(), AsmError> {
        let inst = c_mul(rd_rs1_p, rs2_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_mv(&mut self, rd_n0: Reg, c_rs2_n0: u32) -> Result<(), AsmError> {
        let inst = c_mv(rd_n0, c_rs2_n0);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_nop(&mut self, c_nzimm6lohi: i32) -> Result<(), AsmError> {
        let inst = c_nop(c_nzimm6lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_not(&mut self, rd_rs1_p: Reg) -> Result<(), AsmError> {
        let inst = c_not(rd_rs1_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_ntl_all(&mut self, ) -> Result<(), AsmError> {
        let inst = c_ntl_all();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_ntl_p1(&mut self, ) -> Result<(), AsmError> {
        let inst = c_ntl_p1();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_ntl_pall(&mut self, ) -> Result<(), AsmError> {
        let inst = c_ntl_pall();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_ntl_s1(&mut self, ) -> Result<(), AsmError> {
        let inst = c_ntl_s1();

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_or(&mut self, rd_rs1_p: Reg, rs2_p: Reg) -> Result<(), AsmError> {
        let inst = c_or(rd_rs1_p, rs2_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_sb(&mut self, rs2_p: Reg, rs1_p: Reg, c_uimm2: u32) -> Result<(), AsmError> {
        let inst = c_sb(rs2_p, rs1_p, c_uimm2);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_sd(&mut self, rs1_p: Reg, rs2_p: Reg, c_uimm8lohi: u32) -> Result<(), AsmError> {
        let inst = c_sd(rs1_p, rs2_p, c_uimm8lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_sdsp(&mut self, c_rs2: u32, c_uimm9sp_s: u32) -> Result<(), AsmError> {
        let inst = c_sdsp(c_rs2, c_uimm9sp_s);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_sext_b(&mut self, rd_rs1_p: Reg) -> Result<(), AsmError> {
        let inst = c_sext_b(rd_rs1_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_sext_h(&mut self, rd_rs1_p: Reg) -> Result<(), AsmError> {
        let inst = c_sext_h(rd_rs1_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_sh(&mut self, rs2_p: Reg, rs1_p: Reg, c_uimm1: u32) -> Result<(), AsmError> {
        let inst = c_sh(rs2_p, rs1_p, c_uimm1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_slli(&mut self, rd_rs1_n0: Reg, c_nzuimm6lohi: u32) -> Result<(), AsmError> {
        let inst = c_slli(rd_rs1_n0, c_nzuimm6lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_srai(&mut self, rd_rs1_p: Reg, c_nzuimm6lohi: u32) -> Result<(), AsmError> {
        let inst = c_srai(rd_rs1_p, c_nzuimm6lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_srli(&mut self, rd_rs1_p: Reg, c_nzuimm6lohi: u32) -> Result<(), AsmError> {
        let inst = c_srli(rd_rs1_p, c_nzuimm6lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_sub(&mut self, rd_rs1_p: Reg, rs2_p: Reg) -> Result<(), AsmError> {
        let inst = c_sub(rd_rs1_p, rs2_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_subw(&mut self, rd_rs1_p: Reg, rs2_p: Reg) -> Result<(), AsmError> {
        let inst = c_subw(rd_rs1_p, rs2_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_sw(&mut self, rs1_p: Reg, rs2_p: Reg, c_uimm7lohi: u32) -> Result<(), AsmError> {
        let inst = c_sw(rs1_p, rs2_p, c_uimm7lohi);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_swsp(&mut self, c_rs2: u32, c_uimm8sp_s: u32) -> Result<(), AsmError> {
        let inst = c_swsp(c_rs2, c_uimm8sp_s);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_xor(&mut self, rd_rs1_p: Reg, rs2_p: Reg) -> Result<(), AsmError> {
        let inst = c_xor(rd_rs1_p, rs2_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_zext_b(&mut self, rd_rs1_p: Reg) -> Result<(), AsmError> {
        let inst = c_zext_b(rd_rs1_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_zext_h(&mut self, rd_rs1_p: Reg) -> Result<(), AsmError> {
        let inst = c_zext_h(rd_rs1_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn c_zext_w(&mut self, rd_rs1_p: Reg) -> Result<(), AsmError> {
        let inst = c_zext_w(rd_rs1_p);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cbo_clean(&mut self, rs1: Reg) -> Result<(), AsmError> {
        let inst = cbo_clean(rs1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cbo_flush(&mut self, rs1: Reg) -> Result<(), AsmError> {
        let inst = cbo_flush(rs1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cbo_inval(&mut self, rs1: Reg) -> Result<(), AsmError> {
        let inst = cbo_inval(rs1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cbo_zero(&mut self, rs1: Reg) -> Result<(), AsmError> {
        let inst = cbo_zero(rs1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn clmul(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = clmul(rd, rs1, rs2);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn clmulh(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = clmulh(rd, rs1, rs2);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn clmulr(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = clmulr(rd, rs1, rs2);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn clz(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = clz(rd, rs1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn clzw(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = clzw(rd, rs1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cm_jalt(&mut self, c_index: u32) -> Result<(), AsmError> {
        let inst = cm_jalt(c_index);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cm_mva01s(&mut self, c_sreg1: u32, c_sreg2: u32) -> Result<(), AsmError> {
        let inst = cm_mva01s(c_sreg1, c_sreg2);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cm_mvsa01(&mut self, c_sreg1: u32, c_sreg2: u32) -> Result<(), AsmError> {
        let inst = cm_mvsa01(c_sreg1, c_sreg2);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cm_pop(&mut self, c_rlist: u32, c_spimm: i32) -> Result<(), AsmError> {
        let inst = cm_pop(c_rlist, c_spimm);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cm_popret(&mut self, c_rlist: u32, c_spimm: i32) -> Result<(), AsmError> {
        let inst = cm_popret(c_rlist, c_spimm);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cm_popretz(&mut self, c_rlist: u32, c_spimm: i32) -> Result<(), AsmError> {
        let inst = cm_popretz(c_rlist, c_spimm);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cm_push(&mut self, c_rlist: u32, c_spimm: i32) -> Result<(), AsmError> {
        let inst = cm_push(c_rlist, c_spimm);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cpop(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = cpop(rd, rs1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn cpopw(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = cpopw(rd, rs1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrc(&mut self, rs1: Reg, csr: u32) -> Result<(), AsmError> {
        let inst = csrc(rs1, csr);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrci(&mut self, csr: u32, zimm: i32) -> Result<(), AsmError> {
        let inst = csrci(csr, zimm);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrr(&mut self, rd: Reg, csr: u32) -> Result<(), AsmError> {
        let inst = csrr(rd, csr);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrrc(&mut self, rd: Reg, rs1: Reg, csr: u32) -> Result<(), AsmError> {
        let inst = csrrc(rd, rs1, csr);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrrci(&mut self, rd: Reg, csr: u32, zimm: i32) -> Result<(), AsmError> {
        let inst = csrrci(rd, csr, zimm);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrrs(&mut self, rd: Reg, rs1: Reg, csr: u32) -> Result<(), AsmError> {
        let inst = csrrs(rd, rs1, csr);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrrsi(&mut self, rd: Reg, csr: u32, zimm: i32) -> Result<(), AsmError> {
        let inst = csrrsi(rd, csr, zimm);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrrw(&mut self, rd: Reg, rs1: Reg, csr: u32) -> Result<(), AsmError> {
        let inst = csrrw(rd, rs1, csr);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrrwi(&mut self, rd: Reg, csr: u32, zimm: i32) -> Result<(), AsmError> {
        let inst = csrrwi(rd, csr, zimm);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrs(&mut self, rs1: Reg, csr: u32) -> Result<(), AsmError> {
        let inst = csrs(rs1, csr);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrsi(&mut self, csr: u32, zimm: i32) -> Result<(), AsmError> {
        let inst = csrsi(csr, zimm);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrw(&mut self, rs1: Reg, csr: u32) -> Result<(), AsmError> {
        let inst = csrw(rs1, csr);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn csrwi(&mut self, csr: u32, zimm: i32) -> Result<(), AsmError> {
        let inst = csrwi(csr, zimm);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn ctz(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = ctz(rd, rs1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn ctzw(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = ctzw(rd, rs1);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn czero_eqz(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = czero_eqz(rd, rs1, rs2);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn czero_nez(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = czero_nez(rd, rs1, rs2);

        self.emit_compressed(inst);

        Ok(())
    }
        
    pub fn div(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = div(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn divu(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = divu(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn divuw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = divuw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn divw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = divw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn dret(&mut self, ) -> Result<(), AsmError> {
        let inst = dret();

        self.emit(inst);

        Ok(())
    }
        
    pub fn ebreak(&mut self, ) -> Result<(), AsmError> {
        let inst = ebreak();

        self.emit(inst);

        Ok(())
    }
        
    pub fn ecall(&mut self, ) -> Result<(), AsmError> {
        let inst = ecall();

        self.emit(inst);

        Ok(())
    }
        
    pub fn fabs_d(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fabs_d(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fabs_h(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fabs_h(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fabs_q(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fabs_q(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fabs_s(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fabs_s(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fadd_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fadd_d(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fadd_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fadd_h(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fadd_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fadd_q(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fadd_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fadd_s(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fclass_d(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fclass_d(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fclass_h(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fclass_h(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fclass_q(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fclass_q(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fclass_s(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fclass_s(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_d_h(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_d_h(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_d_l(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_d_l(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_d_lu(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_d_lu(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_d_q(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_d_q(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_d_s(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_d_s(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_d_w(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_d_w(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_d_wu(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_d_wu(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_h_d(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_h_d(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_h_l(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_h_l(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_h_lu(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_h_lu(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_h_q(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_h_q(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_h_s(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_h_s(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_h_w(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_h_w(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_h_wu(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_h_wu(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_l_d(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_l_d(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_l_h(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_l_h(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_l_q(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_l_q(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_l_s(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_l_s(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_lu_d(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_lu_d(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_lu_h(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_lu_h(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_lu_q(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_lu_q(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_lu_s(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_lu_s(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_q_d(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_q_d(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_q_h(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_q_h(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_q_l(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_q_l(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_q_lu(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_q_lu(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_q_s(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_q_s(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_q_w(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_q_w(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_q_wu(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_q_wu(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_s_d(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_s_d(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_s_h(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_s_h(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_s_l(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_s_l(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_s_lu(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_s_lu(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_s_q(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_s_q(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_s_w(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_s_w(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_s_wu(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_s_wu(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_w_d(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_w_d(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_w_h(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_w_h(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_w_q(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_w_q(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_w_s(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_w_s(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_wu_d(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_wu_d(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_wu_h(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_wu_h(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_wu_q(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_wu_q(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvt_wu_s(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fcvt_wu_s(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fcvtmod_w_d(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fcvtmod_w_d(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fdiv_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fdiv_d(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fdiv_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fdiv_h(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fdiv_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fdiv_q(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fdiv_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fdiv_s(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fence(&mut self, fm: u32, pred: u32, succ: u32, rs1: Reg, rd: Reg) -> Result<(), AsmError> {
        let inst = fence(fm, pred, succ, rs1, rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fence_i(&mut self, imm12: i32, rs1: Reg, rd: Reg) -> Result<(), AsmError> {
        let inst = fence_i(imm12, rs1, rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fence_tso(&mut self, rs1: Reg, rd: Reg) -> Result<(), AsmError> {
        let inst = fence_tso(rs1, rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn feq_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = feq_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn feq_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = feq_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn feq_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = feq_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn feq_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = feq_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fld(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = fld(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fle_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fle_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fle_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fle_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fle_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fle_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fle_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fle_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fleq_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fleq_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fleq_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fleq_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fleq_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fleq_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fleq_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fleq_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn flh(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = flh(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fli_d(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fli_d(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fli_h(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fli_h(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fli_q(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fli_q(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fli_s(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fli_s(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn flq(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = flq(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn flt_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = flt_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn flt_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = flt_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn flt_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = flt_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn flt_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = flt_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fltq_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fltq_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fltq_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fltq_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fltq_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fltq_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fltq_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fltq_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn flw(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = flw(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmadd_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmadd_d(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmadd_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmadd_h(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmadd_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmadd_q(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmadd_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmadd_s(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmax_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmax_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmax_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmax_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmax_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmax_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmax_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmax_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmaxm_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmaxm_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmaxm_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmaxm_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmaxm_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmaxm_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmaxm_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmaxm_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmin_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmin_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmin_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmin_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmin_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmin_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmin_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmin_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fminm_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fminm_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fminm_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fminm_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fminm_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fminm_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fminm_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fminm_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmsub_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmsub_d(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmsub_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmsub_h(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmsub_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmsub_q(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmsub_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmsub_s(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmul_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmul_d(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmul_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmul_h(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmul_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmul_q(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmul_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fmul_s(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_d(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_d(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_d_x(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_d_x(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_h(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_h(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_h_x(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_h_x(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_q(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_q(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_s(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_s(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_s_x(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_s_x(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_w_x(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_w_x(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_x_d(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_x_d(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_x_h(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_x_h(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_x_s(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_x_s(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmv_x_w(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fmv_x_w(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmvh_x_q(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fmvh_x_q(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fmvp_q_x(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fmvp_q_x(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fneg_d(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fneg_d(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fneg_h(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fneg_h(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fneg_q(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fneg_q(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fneg_s(&mut self, rd: Reg, rs1: Reg, rs2_eq_rs1: Reg) -> Result<(), AsmError> {
        let inst = fneg_s(rd, rs1, rs2_eq_rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fnmadd_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fnmadd_d(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fnmadd_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fnmadd_h(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fnmadd_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fnmadd_q(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fnmadd_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fnmadd_s(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fnmsub_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fnmsub_d(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fnmsub_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fnmsub_h(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fnmsub_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fnmsub_q(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fnmsub_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rs3: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fnmsub_s(rd, rs1, rs2, rs3, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn frcsr(&mut self, rd: Reg) -> Result<(), AsmError> {
        let inst = frcsr(rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn frflags(&mut self, rd: Reg) -> Result<(), AsmError> {
        let inst = frflags(rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fround_d(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fround_d(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fround_h(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fround_h(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fround_q(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fround_q(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fround_s(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fround_s(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn froundnx_d(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = froundnx_d(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn froundnx_h(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = froundnx_h(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn froundnx_q(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = froundnx_q(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn froundnx_s(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = froundnx_s(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn frrm(&mut self, rd: Reg) -> Result<(), AsmError> {
        let inst = frrm(rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fscsr(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fscsr(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsd(&mut self, imm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsd(imm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsflags(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fsflags(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsflagsi(&mut self, rd: Reg, zimm: i32) -> Result<(), AsmError> {
        let inst = fsflagsi(rd, zimm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnj_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnj_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnj_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnj_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnj_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnj_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnj_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnj_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnjn_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnjn_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnjn_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnjn_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnjn_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnjn_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnjn_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnjn_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnjx_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnjx_d(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnjx_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnjx_h(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnjx_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnjx_q(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsgnjx_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsgnjx_s(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsh(&mut self, imm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsh(imm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsq(&mut self, imm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsq(imm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsqrt_d(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fsqrt_d(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsqrt_h(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fsqrt_h(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsqrt_q(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fsqrt_q(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsqrt_s(&mut self, rd: Reg, rs1: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fsqrt_s(rd, rs1, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsrm(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = fsrm(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsrmi(&mut self, rd: Reg, zimm: i32) -> Result<(), AsmError> {
        let inst = fsrmi(rd, zimm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsub_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fsub_d(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsub_h(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fsub_h(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsub_q(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fsub_q(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsub_s(&mut self, rd: Reg, rs1: Reg, rs2: Reg, rm: Reg) -> Result<(), AsmError> {
        let inst = fsub_s(rd, rs1, rs2, rm);

        self.emit(inst);

        Ok(())
    }
        
    pub fn fsw(&mut self, imm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = fsw(imm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hfence_gvma(&mut self, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = hfence_gvma(rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hfence_vvma(&mut self, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = hfence_vvma(rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hinval_gvma(&mut self, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = hinval_gvma(rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hinval_vvma(&mut self, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = hinval_vvma(rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hlv_b(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = hlv_b(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hlv_bu(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = hlv_bu(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hlv_d(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = hlv_d(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hlv_h(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = hlv_h(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hlv_hu(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = hlv_hu(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hlv_w(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = hlv_w(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hlv_wu(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = hlv_wu(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hlvx_hu(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = hlvx_hu(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hlvx_wu(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = hlvx_wu(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hsv_b(&mut self, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = hsv_b(rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hsv_d(&mut self, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = hsv_d(rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hsv_h(&mut self, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = hsv_h(rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn hsv_w(&mut self, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = hsv_w(rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn j(&mut self, jimm20: i32) -> Result<(), AsmError> {
        let inst = j(jimm20);

        self.emit(inst);

        Ok(())
    }
        
    pub fn jal(&mut self, rd: Reg, jimm20: i32) -> Result<(), AsmError> {
        let inst = jal(rd, jimm20);

        self.emit(inst);

        Ok(())
    }
        
    pub fn jal_pseudo(&mut self, jimm20: i32) -> Result<(), AsmError> {
        let inst = jal_pseudo(jimm20);

        self.emit(inst);

        Ok(())
    }
        
    pub fn jalr(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = jalr(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn jalr_pseudo(&mut self, rs1: Reg) -> Result<(), AsmError> {
        let inst = jalr_pseudo(rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn jr(&mut self, rs1: Reg) -> Result<(), AsmError> {
        let inst = jr(rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn lb(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = lb(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn lbu(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = lbu(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn ld(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = ld(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn lh(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = lh(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn lhu(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = lhu(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn lr_d(&mut self, rd: Reg, rs1: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = lr_d(rd, rs1, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn lr_w(&mut self, rd: Reg, rs1: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = lr_w(rd, rs1, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn lui(&mut self, rd: Reg, imm20: i32) -> Result<(), AsmError> {
        let inst = lui(rd, imm20);

        self.emit(inst);

        Ok(())
    }
        
    pub fn lw(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = lw(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn lwu(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = lwu(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn max(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = max(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn maxu(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = maxu(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn min(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = min(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn minu(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = minu(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_0(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_0(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_1(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_1(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_10(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_10(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_11(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_11(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_12(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_12(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_13(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_13(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_14(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_14(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_15(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_15(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_16(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_16(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_17(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_17(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_18(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_18(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_19(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_19(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_2(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_2(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_20(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_20(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_21(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_21(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_22(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_22(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_23(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_23(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_24(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_24(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_25(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_25(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_26(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_26(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_27(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_27(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_28(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_28(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_29(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_29(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_3(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_3(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_30(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_30(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_31(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_31(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_4(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_4(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_5(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_5(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_6(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_6(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_7(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_7(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_8(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_8(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_9(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_9(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_r_n(&mut self, mop_r_t_30: u32, mop_r_t_27_26: u32, mop_r_t_21_20: u32, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mop_r_n(mop_r_t_30, mop_r_t_27_26, mop_r_t_21_20, rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_rr_0(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mop_rr_0(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_rr_1(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mop_rr_1(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_rr_2(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mop_rr_2(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_rr_3(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mop_rr_3(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_rr_4(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mop_rr_4(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_rr_5(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mop_rr_5(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_rr_6(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mop_rr_6(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_rr_7(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mop_rr_7(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mop_rr_n(&mut self, mop_rr_t_30: u32, mop_rr_t_27_26: u32, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mop_rr_n(mop_rr_t_30, mop_rr_t_27_26, rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mret(&mut self, ) -> Result<(), AsmError> {
        let inst = mret();

        self.emit(inst);

        Ok(())
    }
        
    pub fn mul(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mul(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mulh(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mulh(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mulhsu(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mulhsu(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mulhu(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mulhu(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mulw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = mulw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn mv(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = mv(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn neg(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = neg(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn nop(&mut self, ) -> Result<(), AsmError> {
        let inst = nop();

        self.emit(inst);

        Ok(())
    }
        
    pub fn ntl_all(&mut self, ) -> Result<(), AsmError> {
        let inst = ntl_all();

        self.emit(inst);

        Ok(())
    }
        
    pub fn ntl_p1(&mut self, ) -> Result<(), AsmError> {
        let inst = ntl_p1();

        self.emit(inst);

        Ok(())
    }
        
    pub fn ntl_pall(&mut self, ) -> Result<(), AsmError> {
        let inst = ntl_pall();

        self.emit(inst);

        Ok(())
    }
        
    pub fn ntl_s1(&mut self, ) -> Result<(), AsmError> {
        let inst = ntl_s1();

        self.emit(inst);

        Ok(())
    }
        
    pub fn or(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = or(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn orc_b(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = orc_b(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn ori(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = ori(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn orn(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = orn(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn pack(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = pack(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn packh(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = packh(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn packw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = packw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn pause(&mut self, ) -> Result<(), AsmError> {
        let inst = pause();

        self.emit(inst);

        Ok(())
    }
        
    pub fn prefetch_i(&mut self, rs1: Reg, imm12lohi: i32) -> Result<(), AsmError> {
        let inst = prefetch_i(rs1, imm12lohi);

        self.emit(inst);

        Ok(())
    }
        
    pub fn prefetch_r(&mut self, rs1: Reg, imm12lohi: i32) -> Result<(), AsmError> {
        let inst = prefetch_r(rs1, imm12lohi);

        self.emit(inst);

        Ok(())
    }
        
    pub fn prefetch_w(&mut self, rs1: Reg, imm12lohi: i32) -> Result<(), AsmError> {
        let inst = prefetch_w(rs1, imm12lohi);

        self.emit(inst);

        Ok(())
    }
        
    pub fn rdcycle(&mut self, rd: Reg) -> Result<(), AsmError> {
        let inst = rdcycle(rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn rdinstret(&mut self, rd: Reg) -> Result<(), AsmError> {
        let inst = rdinstret(rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn rdtime(&mut self, rd: Reg) -> Result<(), AsmError> {
        let inst = rdtime(rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn rem(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = rem(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn remu(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = remu(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn remuw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = remuw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn remw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = remw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn ret(&mut self, ) -> Result<(), AsmError> {
        let inst = ret();

        self.emit(inst);

        Ok(())
    }
        
    pub fn rev8(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = rev8(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn rol(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = rol(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn rolw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = rolw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn ror(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = ror(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn rori(&mut self, rd: Reg, rs1: Reg, shamtd: u32) -> Result<(), AsmError> {
        let inst = rori(rd, rs1, shamtd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn roriw(&mut self, rd: Reg, rs1: Reg, shamtw: u32) -> Result<(), AsmError> {
        let inst = roriw(rd, rs1, shamtw);

        self.emit(inst);

        Ok(())
    }
        
    pub fn rorw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = rorw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sb(&mut self, imm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sb(imm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sbreak(&mut self, ) -> Result<(), AsmError> {
        let inst = sbreak();

        self.emit(inst);

        Ok(())
    }
        
    pub fn sc_d(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = sc_d(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sc_w(&mut self, rd: Reg, rs1: Reg, rs2: Reg, aq: bool, rl: Reg) -> Result<(), AsmError> {
        let inst = sc_w(rd, rs1, rs2, aq, rl);

        self.emit(inst);

        Ok(())
    }
        
    pub fn scall(&mut self, ) -> Result<(), AsmError> {
        let inst = scall();

        self.emit(inst);

        Ok(())
    }
        
    pub fn sd(&mut self, imm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sd(imm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn seqz(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = seqz(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sext_b(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sext_b(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sext_h(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sext_h(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sext_w(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sext_w(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sfence_inval_ir(&mut self, ) -> Result<(), AsmError> {
        let inst = sfence_inval_ir();

        self.emit(inst);

        Ok(())
    }
        
    pub fn sfence_vma(&mut self, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sfence_vma(rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sfence_w_inval(&mut self, ) -> Result<(), AsmError> {
        let inst = sfence_w_inval();

        self.emit(inst);

        Ok(())
    }
        
    pub fn sgtz(&mut self, rd: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sgtz(rd, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sh(&mut self, imm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sh(imm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sh1add(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sh1add(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sh1add_uw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sh1add_uw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sh2add(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sh2add(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sh2add_uw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sh2add_uw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sh3add(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sh3add(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sh3add_uw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sh3add_uw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sha256sig0(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sha256sig0(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sha256sig1(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sha256sig1(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sha256sum0(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sha256sum0(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sha256sum1(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sha256sum1(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sha512sig0(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sha512sig0(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sha512sig1(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sha512sig1(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sha512sum0(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sha512sum0(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sha512sum1(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sha512sum1(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sinval_vma(&mut self, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sinval_vma(rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sll(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sll(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn slli(&mut self, rd: Reg, rs1: Reg, shamtd: u32) -> Result<(), AsmError> {
        let inst = slli(rd, rs1, shamtd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn slli_uw(&mut self, rd: Reg, rs1: Reg, shamtd: u32) -> Result<(), AsmError> {
        let inst = slli_uw(rd, rs1, shamtd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn slliw(&mut self, rd: Reg, rs1: Reg, shamtw: u32) -> Result<(), AsmError> {
        let inst = slliw(rd, rs1, shamtw);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sllw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sllw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn slt(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = slt(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn slti(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = slti(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sltiu(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = sltiu(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sltu(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sltu(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sltz(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sltz(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sm3p0(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sm3p0(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sm3p1(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = sm3p1(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sm4ed(&mut self, rd: Reg, rs1: Reg, rs2: Reg, bs: u32) -> Result<(), AsmError> {
        let inst = sm4ed(rd, rs1, rs2, bs);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sm4ks(&mut self, rd: Reg, rs1: Reg, rs2: Reg, bs: u32) -> Result<(), AsmError> {
        let inst = sm4ks(rd, rs1, rs2, bs);

        self.emit(inst);

        Ok(())
    }
        
    pub fn snez(&mut self, rd: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = snez(rd, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sra(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sra(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn srai(&mut self, rd: Reg, rs1: Reg, shamtd: u32) -> Result<(), AsmError> {
        let inst = srai(rd, rs1, shamtd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sraiw(&mut self, rd: Reg, rs1: Reg, shamtw: u32) -> Result<(), AsmError> {
        let inst = sraiw(rd, rs1, shamtw);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sraw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sraw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sret(&mut self, ) -> Result<(), AsmError> {
        let inst = sret();

        self.emit(inst);

        Ok(())
    }
        
    pub fn srl(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = srl(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn srli(&mut self, rd: Reg, rs1: Reg, shamtd: u32) -> Result<(), AsmError> {
        let inst = srli(rd, rs1, shamtd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn srliw(&mut self, rd: Reg, rs1: Reg, shamtw: u32) -> Result<(), AsmError> {
        let inst = srliw(rd, rs1, shamtw);

        self.emit(inst);

        Ok(())
    }
        
    pub fn srlw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = srlw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sub(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sub(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn subw(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = subw(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn sw(&mut self, imm12lohi: i32, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = sw(imm12lohi, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaadd_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaadd_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaadd_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaadd_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaaddu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaaddu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaaddu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaaddu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vadc_vim(&mut self, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vadc_vim(vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vadc_vvm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vadc_vvm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vadc_vxm(&mut self, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vadc_vxm(vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vadd_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vadd_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vadd_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vadd_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vadd_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vadd_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaesdf_vs(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaesdf_vs(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaesdf_vv(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaesdf_vv(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaesdm_vs(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaesdm_vs(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaesdm_vv(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaesdm_vv(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaesef_vs(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaesef_vs(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaesef_vv(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaesef_vv(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaesem_vs(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaesem_vs(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaesem_vv(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaesem_vv(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaeskf1_vi(&mut self, vs2: VReg, zimm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vaeskf1_vi(vs2, zimm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaeskf2_vi(&mut self, vs2: VReg, zimm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vaeskf2_vi(vs2, zimm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vaesz_vs(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vaesz_vs(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vand_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vand_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vand_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vand_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vand_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vand_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vandn_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vandn_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vandn_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vandn_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vasub_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vasub_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vasub_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vasub_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vasubu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vasubu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vasubu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vasubu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vbrev8_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vbrev8_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vbrev_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vbrev_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vclmul_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vclmul_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vclmul_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vclmul_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vclmulh_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vclmulh_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vclmulh_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vclmulh_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vclz_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vclz_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vcompress_vm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vcompress_vm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vcpop_m(&mut self, vm: VReg, vs2: VReg, rd: Reg) -> Result<(), AsmError> {
        let inst = vcpop_m(vm, vs2, rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vcpop_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vcpop_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vctz_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vctz_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vdiv_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vdiv_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vdiv_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vdiv_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vdivu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vdivu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vdivu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vdivu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfadd_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfadd_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfadd_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfadd_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfclass_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfclass_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfcvt_f_x_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfcvt_f_x_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfcvt_f_xu_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfcvt_f_xu_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfcvt_rtz_x_f_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfcvt_rtz_x_f_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfcvt_rtz_xu_f_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfcvt_rtz_xu_f_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfcvt_x_f_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfcvt_x_f_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfcvt_xu_f_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfcvt_xu_f_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfdiv_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfdiv_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfdiv_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfdiv_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfirst_m(&mut self, vm: VReg, vs2: VReg, rd: Reg) -> Result<(), AsmError> {
        let inst = vfirst_m(vm, vs2, rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmacc_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmacc_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmacc_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmacc_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmadd_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmadd_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmadd_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmadd_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmax_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmax_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmax_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmax_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmerge_vfm(&mut self, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmerge_vfm(vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmin_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmin_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmin_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmin_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmsac_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmsac_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmsac_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmsac_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmsub_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmsub_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmsub_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmsub_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmul_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmul_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmul_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmul_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmv_f_s(&mut self, vs2: VReg, rd: Reg) -> Result<(), AsmError> {
        let inst = vfmv_f_s(vs2, rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmv_s_f(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmv_s_f(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfmv_v_f(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfmv_v_f(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfncvt_f_f_w(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfncvt_f_f_w(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfncvt_f_x_w(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfncvt_f_x_w(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfncvt_f_xu_w(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfncvt_f_xu_w(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfncvt_rod_f_f_w(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfncvt_rod_f_f_w(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfncvt_rtz_x_f_w(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfncvt_rtz_x_f_w(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfncvt_rtz_xu_f_w(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfncvt_rtz_xu_f_w(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfncvt_x_f_w(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfncvt_x_f_w(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfncvt_xu_f_w(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfncvt_xu_f_w(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfnmacc_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfnmacc_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfnmacc_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfnmacc_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfnmadd_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfnmadd_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfnmadd_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfnmadd_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfnmsac_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfnmsac_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfnmsac_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfnmsac_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfnmsub_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfnmsub_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfnmsub_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfnmsub_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfrdiv_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfrdiv_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfrec7_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfrec7_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfredmax_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfredmax_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfredmin_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfredmin_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfredosum_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfredosum_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfredsum_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfredsum_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfredusum_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfredusum_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfrsqrt7_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfrsqrt7_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfrsub_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfrsub_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfsgnj_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfsgnj_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfsgnj_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfsgnj_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfsgnjn_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfsgnjn_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfsgnjn_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfsgnjn_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfsgnjx_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfsgnjx_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfsgnjx_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfsgnjx_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfslide1down_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfslide1down_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfslide1up_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfslide1up_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfsqrt_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfsqrt_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfsub_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfsub_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfsub_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfsub_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwadd_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwadd_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwadd_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwadd_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwadd_wf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwadd_wf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwadd_wv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwadd_wv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwcvt_f_f_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwcvt_f_f_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwcvt_f_x_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwcvt_f_x_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwcvt_f_xu_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwcvt_f_xu_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwcvt_rtz_x_f_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwcvt_rtz_x_f_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwcvt_rtz_xu_f_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwcvt_rtz_xu_f_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwcvt_x_f_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwcvt_x_f_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwcvt_xu_f_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwcvt_xu_f_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwmacc_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwmacc_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwmacc_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwmacc_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwmsac_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwmsac_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwmsac_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwmsac_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwmul_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwmul_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwmul_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwmul_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwnmacc_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwnmacc_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwnmacc_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwnmacc_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwnmsac_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwnmsac_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwnmsac_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwnmsac_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwredosum_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwredosum_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwredsum_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwredsum_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwredusum_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwredusum_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwsub_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwsub_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwsub_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwsub_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwsub_wf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwsub_wf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vfwsub_wv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vfwsub_wv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vghsh_vv(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vghsh_vv(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vgmul_vv(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vgmul_vv(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vid_v(&mut self, vm: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vid_v(vm, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn viota_m(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = viota_m(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl1r_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl1r_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl1re16_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl1re16_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl1re32_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl1re32_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl1re64_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl1re64_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl1re8_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl1re8_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl2r_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl2r_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl2re16_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl2re16_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl2re32_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl2re32_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl2re64_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl2re64_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl2re8_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl2re8_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl4r_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl4r_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl4re16_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl4re16_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl4re32_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl4re32_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl4re64_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl4re64_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl4re8_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl4re8_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl8r_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl8r_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl8re16_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl8re16_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl8re32_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl8re32_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl8re64_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl8re64_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vl8re8_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vl8re8_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vle16_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vle16_v(nf, vm, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vle16ff_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vle16ff_v(nf, vm, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vle1_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vle1_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vle32_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vle32_v(nf, vm, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vle32ff_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vle32ff_v(nf, vm, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vle64_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vle64_v(nf, vm, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vle64ff_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vle64ff_v(nf, vm, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vle8_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vle8_v(nf, vm, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vle8ff_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vle8ff_v(nf, vm, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vlm_v(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vlm_v(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vloxei16_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vloxei16_v(nf, vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vloxei32_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vloxei32_v(nf, vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vloxei64_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vloxei64_v(nf, vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vloxei8_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vloxei8_v(nf, vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vlse16_v(&mut self, nf: u32, vm: VReg, rs2: Reg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vlse16_v(nf, vm, rs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vlse32_v(&mut self, nf: u32, vm: VReg, rs2: Reg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vlse32_v(nf, vm, rs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vlse64_v(&mut self, nf: u32, vm: VReg, rs2: Reg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vlse64_v(nf, vm, rs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vlse8_v(&mut self, nf: u32, vm: VReg, rs2: Reg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vlse8_v(nf, vm, rs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vluxei16_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vluxei16_v(nf, vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vluxei32_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vluxei32_v(nf, vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vluxei64_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vluxei64_v(nf, vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vluxei8_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vluxei8_v(nf, vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmacc_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmacc_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmacc_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmacc_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmadc_vi(&mut self, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vmadc_vi(vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmadc_vim(&mut self, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vmadc_vim(vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmadc_vv(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmadc_vv(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmadc_vvm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmadc_vvm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmadc_vx(&mut self, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmadc_vx(vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmadc_vxm(&mut self, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmadc_vxm(vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmadd_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmadd_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmadd_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmadd_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmand_mm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmand_mm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmandn_mm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmandn_mm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmandnot_mm(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmandnot_mm(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmax_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmax_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmax_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmax_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmaxu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmaxu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmaxu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmaxu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmerge_vim(&mut self, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vmerge_vim(vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmerge_vvm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmerge_vvm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmerge_vxm(&mut self, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmerge_vxm(vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmfeq_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmfeq_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmfeq_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmfeq_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmfge_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmfge_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmfgt_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmfgt_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmfle_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmfle_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmfle_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmfle_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmflt_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmflt_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmflt_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmflt_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmfne_vf(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmfne_vf(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmfne_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmfne_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmin_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmin_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmin_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmin_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vminu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vminu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vminu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vminu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmnand_mm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmnand_mm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmnor_mm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmnor_mm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmor_mm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmor_mm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmorn_mm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmorn_mm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmornot_mm(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmornot_mm(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsbc_vv(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsbc_vv(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsbc_vvm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsbc_vvm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsbc_vx(&mut self, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsbc_vx(vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsbc_vxm(&mut self, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsbc_vxm(vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsbf_m(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsbf_m(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmseq_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vmseq_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmseq_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmseq_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmseq_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmseq_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsgt_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsgt_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsgt_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsgt_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsgtu_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsgtu_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsgtu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsgtu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsif_m(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsif_m(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsle_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsle_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsle_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsle_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsle_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsle_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsleu_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsleu_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsleu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsleu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsleu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsleu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmslt_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmslt_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmslt_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmslt_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsltu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsltu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsltu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsltu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsne_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsne_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsne_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsne_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsne_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsne_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmsof_m(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmsof_m(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmul_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmul_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmul_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmul_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmulh_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmulh_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmulh_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmulh_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmulhsu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmulhsu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmulhsu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmulhsu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmulhu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmulhu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmulhu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmulhu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmv1r_v(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmv1r_v(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmv2r_v(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmv2r_v(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmv4r_v(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmv4r_v(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmv8r_v(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmv8r_v(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmv_s_x(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmv_s_x(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmv_v_i(&mut self, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vmv_v_i(simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmv_v_v(&mut self, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmv_v_v(vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmv_v_x(&mut self, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmv_v_x(rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmv_x_s(&mut self, vs2: VReg, rd: Reg) -> Result<(), AsmError> {
        let inst = vmv_x_s(vs2, rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmxnor_mm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmxnor_mm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vmxor_mm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vmxor_mm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnclip_wi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vnclip_wi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnclip_wv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnclip_wv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnclip_wx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnclip_wx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnclipu_wi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vnclipu_wi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnclipu_wv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnclipu_wv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnclipu_wx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnclipu_wx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnmsac_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnmsac_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnmsac_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnmsac_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnmsub_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnmsub_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnmsub_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnmsub_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnsra_wi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vnsra_wi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnsra_wv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnsra_wv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnsra_wx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnsra_wx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnsrl_wi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vnsrl_wi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnsrl_wv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnsrl_wv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vnsrl_wx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vnsrl_wx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vor_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vor_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vor_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vor_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vor_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vor_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vpopc_m(&mut self, vm: VReg, vs2: VReg, rd: Reg) -> Result<(), AsmError> {
        let inst = vpopc_m(vm, vs2, rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vredand_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vredand_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vredmax_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vredmax_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vredmaxu_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vredmaxu_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vredmin_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vredmin_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vredminu_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vredminu_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vredor_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vredor_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vredsum_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vredsum_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vredxor_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vredxor_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vrem_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vrem_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vrem_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vrem_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vremu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vremu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vremu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vremu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vrev8_v(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vrev8_v(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vrgather_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vrgather_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vrgather_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vrgather_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vrgather_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vrgather_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vrgatherei16_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vrgatherei16_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vrol_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vrol_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vrol_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vrol_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vror_vi(&mut self, zimm6lohi: i32, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vror_vi(zimm6lohi, vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vror_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vror_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vror_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vror_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vrsub_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vrsub_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vrsub_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vrsub_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vs1r_v(&mut self, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vs1r_v(rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vs2r_v(&mut self, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vs2r_v(rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vs4r_v(&mut self, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vs4r_v(rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vs8r_v(&mut self, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vs8r_v(rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsadd_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vsadd_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsadd_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsadd_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsadd_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsadd_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsaddu_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vsaddu_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsaddu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsaddu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsaddu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsaddu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsbc_vvm(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsbc_vvm(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsbc_vxm(&mut self, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsbc_vxm(vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vse16_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vse16_v(nf, vm, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vse1_v(&mut self, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vse1_v(rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vse32_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vse32_v(nf, vm, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vse64_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vse64_v(nf, vm, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vse8_v(&mut self, nf: u32, vm: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vse8_v(nf, vm, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsetivli(&mut self, zimm10: i32, zimm: i32, rd: Reg) -> Result<(), AsmError> {
        let inst = vsetivli(zimm10, zimm, rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsetvl(&mut self, rs2: Reg, rs1: Reg, rd: Reg) -> Result<(), AsmError> {
        let inst = vsetvl(rs2, rs1, rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsetvli(&mut self, zimm11: i32, rs1: Reg, rd: Reg) -> Result<(), AsmError> {
        let inst = vsetvli(zimm11, rs1, rd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsext_vf2(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsext_vf2(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsext_vf4(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsext_vf4(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsext_vf8(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsext_vf8(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsha2ch_vv(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsha2ch_vv(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsha2cl_vv(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsha2cl_vv(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsha2ms_vv(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsha2ms_vv(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vslide1down_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vslide1down_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vslide1up_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vslide1up_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vslidedown_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vslidedown_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vslidedown_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vslidedown_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vslideup_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vslideup_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vslideup_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vslideup_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsll_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vsll_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsll_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsll_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsll_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsll_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsm3c_vi(&mut self, vs2: VReg, zimm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vsm3c_vi(vs2, zimm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsm3me_vv(&mut self, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsm3me_vv(vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsm4k_vi(&mut self, vs2: VReg, zimm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vsm4k_vi(vs2, zimm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsm4r_vs(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsm4r_vs(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsm4r_vv(&mut self, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsm4r_vv(vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsm_v(&mut self, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsm_v(rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsmul_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsmul_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsmul_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsmul_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsoxei16_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsoxei16_v(nf, vm, vs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsoxei32_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsoxei32_v(nf, vm, vs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsoxei64_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsoxei64_v(nf, vm, vs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsoxei8_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsoxei8_v(nf, vm, vs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsra_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vsra_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsra_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsra_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsra_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsra_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsrl_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vsrl_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsrl_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsrl_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsrl_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsrl_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsse16_v(&mut self, nf: u32, vm: VReg, rs2: Reg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsse16_v(nf, vm, rs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsse32_v(&mut self, nf: u32, vm: VReg, rs2: Reg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsse32_v(nf, vm, rs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsse64_v(&mut self, nf: u32, vm: VReg, rs2: Reg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsse64_v(nf, vm, rs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsse8_v(&mut self, nf: u32, vm: VReg, rs2: Reg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsse8_v(nf, vm, rs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vssra_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vssra_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vssra_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vssra_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vssra_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vssra_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vssrl_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vssrl_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vssrl_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vssrl_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vssrl_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vssrl_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vssub_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vssub_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vssub_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vssub_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vssubu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vssubu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vssubu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vssubu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsub_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsub_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsub_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vsub_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsuxei16_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsuxei16_v(nf, vm, vs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsuxei32_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsuxei32_v(nf, vm, vs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsuxei64_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsuxei64_v(nf, vm, vs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vsuxei8_v(&mut self, nf: u32, vm: VReg, vs2: VReg, rs1: Reg, vs3: VReg) -> Result<(), AsmError> {
        let inst = vsuxei8_v(nf, vm, vs2, rs1, vs3);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwadd_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwadd_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwadd_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwadd_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwadd_wv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwadd_wv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwadd_wx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwadd_wx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwaddu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwaddu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwaddu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwaddu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwaddu_wv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwaddu_wv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwaddu_wx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwaddu_wx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmacc_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmacc_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmacc_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmacc_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmaccsu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmaccsu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmaccsu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmaccsu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmaccu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmaccu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmaccu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmaccu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmaccus_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmaccus_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmul_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmul_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmul_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmul_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmulsu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmulsu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmulsu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmulsu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmulu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmulu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwmulu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwmulu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwredsum_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwredsum_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwredsumu_vs(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwredsumu_vs(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwsll_vi(&mut self, vm: VReg, vs2: VReg, zimm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vwsll_vi(vm, vs2, zimm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwsll_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwsll_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwsll_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwsll_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwsub_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwsub_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwsub_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwsub_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwsub_wv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwsub_wv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwsub_wx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwsub_wx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwsubu_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwsubu_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwsubu_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwsubu_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwsubu_wv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwsubu_wv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vwsubu_wx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vwsubu_wx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vxor_vi(&mut self, vm: VReg, vs2: VReg, simm5: i32, vd: VReg) -> Result<(), AsmError> {
        let inst = vxor_vi(vm, vs2, simm5, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vxor_vv(&mut self, vm: VReg, vs2: VReg, vs1: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vxor_vv(vm, vs2, vs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vxor_vx(&mut self, vm: VReg, vs2: VReg, rs1: Reg, vd: VReg) -> Result<(), AsmError> {
        let inst = vxor_vx(vm, vs2, rs1, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vzext_vf2(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vzext_vf2(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vzext_vf4(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vzext_vf4(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn vzext_vf8(&mut self, vm: VReg, vs2: VReg, vd: VReg) -> Result<(), AsmError> {
        let inst = vzext_vf8(vm, vs2, vd);

        self.emit(inst);

        Ok(())
    }
        
    pub fn wfi(&mut self, ) -> Result<(), AsmError> {
        let inst = wfi();

        self.emit(inst);

        Ok(())
    }
        
    pub fn wrs_nto(&mut self, ) -> Result<(), AsmError> {
        let inst = wrs_nto();

        self.emit(inst);

        Ok(())
    }
        
    pub fn wrs_sto(&mut self, ) -> Result<(), AsmError> {
        let inst = wrs_sto();

        self.emit(inst);

        Ok(())
    }
        
    pub fn xnor(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = xnor(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn xor(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = xor(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn xori(&mut self, rd: Reg, rs1: Reg, imm12: i32) -> Result<(), AsmError> {
        let inst = xori(rd, rs1, imm12);

        self.emit(inst);

        Ok(())
    }
        
    pub fn xperm4(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = xperm4(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn xperm8(&mut self, rd: Reg, rs1: Reg, rs2: Reg) -> Result<(), AsmError> {
        let inst = xperm8(rd, rs1, rs2);

        self.emit(inst);

        Ok(())
    }
        
    pub fn zext_b(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = zext_b(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        
    pub fn zext_h(&mut self, rd: Reg, rs1: Reg) -> Result<(), AsmError> {
        let inst = zext_h(rd, rs1);

        self.emit(inst);

        Ok(())
    }
        }
        